From 8006d1d142ad9721f4874cd354e51ede5c353326 Mon Sep 17 00:00:00 2001
From: Matt Benjamin <mbenjamin@redhat.com>
Date: Thu, 4 May 2017 14:46:18 -0400
Subject: [PATCH 1/2] XDR and netbuf:  fix decoder overruns from guidovranken

Fixes issues reported in RPCB and generic XDR routines.  In ntirpc,
xdr_inline.h updated along with xdr.c

Signed-off-by: Matt Benjamin <mbenjamin@redhat.com>
---
 ntirpc/rpc/xdr_inline.h | 22 +++++++++++++++++-----
 src/rpc_generic.c       |  6 ++++++
 src/rpcb_st_xdr.c       | 10 ++++++----
 src/xdr.c               | 32 ++++++++++++++++++++++++++------
 4 files changed, 55 insertions(+), 15 deletions(-)

diff --git a/ntirpc/rpc/xdr_inline.h b/ntirpc/rpc/xdr_inline.h
index 6c8a3ba..7d54436 100644
--- a/ntirpc/rpc/xdr_inline.h
+++ b/ntirpc/rpc/xdr_inline.h
@@ -56,7 +56,7 @@
  */
 #define XDR_FALSE ((long) 0)
 #define XDR_TRUE ((long) 1)
-#define LASTUNSIGNED ((u_int) 0-1)
+#define RPC_MAXDATASIZE 9000
 
 /*
  * Free a data structure using XDR
@@ -544,6 +544,7 @@ inline_xdr_bytes(XDR *xdrs, char **cpp, u_int *sizep,
 {
 	char *sp = *cpp;	/* sp is the actual string pointer */
 	u_int nodesize;
+	bool ret;
 
 	/*
 	 * first deal with the length since xdr bytes are counted
@@ -564,7 +565,12 @@ inline_xdr_bytes(XDR *xdrs, char **cpp, u_int *sizep,
 			return (true);
 		if (sp == NULL)
 			*cpp = sp = (char *)mem_alloc(nodesize);
-		return (inline_xdr_getopaque(xdrs, sp, nodesize));
+		ret = inline_xdr_getopaque(xdrs, sp, nodesize);
+		if (! ret) {
+			free(sp);
+			*cpp = NULL;
+		}
+		return (ret);
 
 	case XDR_ENCODE:
 		return (inline_xdr_putopaque(xdrs, sp, nodesize));
@@ -653,6 +659,7 @@ inline_xdr_string(XDR *xdrs, char **cpp, u_int maxsize)
 	char *sp = *cpp;	/* sp is the actual string pointer */
 	u_int size = 0;		/* XXX remove warning */
 	u_int nodesize;
+	bool ret;
 
 	/*
 	 * first deal with the length since xdr strings are counted-strings
@@ -691,8 +698,13 @@ inline_xdr_string(XDR *xdrs, char **cpp, u_int maxsize)
 	case XDR_DECODE:
 		if (sp == NULL)
 			*cpp = sp = (char *)mem_alloc(nodesize);
-		sp[size] = 0;
-		return (inline_xdr_getopaque(xdrs, sp, size));
+		ret = inline_xdr_getopaque(xdrs, sp, size);
+		if (! ret) {
+			free(sp);
+			*cpp = NULL;
+		} else
+			sp[size] = 0;
+		return (ret);
 
 	case XDR_ENCODE:
 		return (inline_xdr_putopaque(xdrs, sp, size));
@@ -713,7 +725,7 @@ inline_xdr_string(XDR *xdrs, char **cpp, u_int maxsize)
 static inline bool
 inline_xdr_wrapstring(XDR *xdrs, char **cpp)
 {
-	return inline_xdr_string(xdrs, cpp, LASTUNSIGNED);
+	return inline_xdr_string(xdrs, cpp, RPC_MAXDATASIZE);
 }
 
 /*
diff --git a/src/rpc_generic.c b/src/rpc_generic.c
index e502cdd..98a8c8f 100644
--- a/src/rpc_generic.c
+++ b/src/rpc_generic.c
@@ -747,6 +747,8 @@ __rpc_taddr2uaddr_af(int af, const struct netbuf *nbuf)
 
 	switch (af) {
 	case AF_INET:
+		if (nbuf->len < sizeof(*sin))
+			return NULL;
 		sin = nbuf->buf;
 		if (inet_ntop(af, &sin->sin_addr, namebuf, sizeof(namebuf))
 		    == NULL)
@@ -761,6 +763,8 @@ __rpc_taddr2uaddr_af(int af, const struct netbuf *nbuf)
 		break;
 #ifdef INET6
 	case AF_INET6:
+		if (nbuf->len < sizeof(*sin6))
+			return NULL;
 		sin6 = nbuf->buf;
 		if (inet_ntop(af, &sin6->sin6_addr, namebuf6, sizeof(namebuf6))
 		    == NULL) {
@@ -827,6 +831,8 @@ __rpc_uaddr2taddr_af(int af, const char *uaddr)
 
 	port = 0;
 	sin = NULL;
+	if (uaddr == NULL)
+		return NULL;
 	addrstr = mem_strdup(uaddr);
 
 	/*
diff --git a/src/rpcb_st_xdr.c b/src/rpcb_st_xdr.c
index a0c022b..dac6ffb 100644
--- a/src/rpcb_st_xdr.c
+++ b/src/rpcb_st_xdr.c
@@ -39,6 +39,8 @@
 #include <sys/cdefs.h>
 
 #include <rpc/rpc.h>
+#include <rpc/xdr.h>
+#include <rpc/xdr_inline.h>
 
 /* Link list of all the stats about getport and getaddr */
 
@@ -53,7 +55,7 @@ xdr_rpcbs_addrlist(XDR *xdrs, rpcbs_addrlist *objp)
 		return (false);
 	if (!xdr_int(xdrs, &objp->failure))
 		return (false);
-	if (!xdr_string(xdrs, &objp->netid, (u_int) ~0))
+	if (!xdr_string(xdrs, &objp->netid, RPC_MAXDATASIZE))
 		return (false);
 	if (!xdr_pointer
 	    (xdrs, (char **)&objp->next, sizeof(rpcbs_addrlist),
@@ -93,7 +95,7 @@ xdr_rpcbs_rmtcalllist(XDR *xdrs, rpcbs_rmtcalllist *objp)
 			IXDR_PUT_INT32(buf, objp->failure);
 			IXDR_PUT_INT32(buf, objp->indirect);
 		}
-		if (!xdr_string(xdrs, &objp->netid, (u_int) ~0))
+		if (!xdr_string(xdrs, &objp->netid, RPC_MAXDATASIZE))
 			return (false);
 		if (!xdr_pointer
 		    (xdrs, (char **)&objp->next, sizeof(rpcbs_rmtcalllist),
@@ -123,7 +125,7 @@ xdr_rpcbs_rmtcalllist(XDR *xdrs, rpcbs_rmtcalllist *objp)
 			objp->failure = (int)IXDR_GET_INT32(buf);
 			objp->indirect = (int)IXDR_GET_INT32(buf);
 		}
-		if (!xdr_string(xdrs, &objp->netid, (u_int) ~0))
+		if (!xdr_string(xdrs, &objp->netid, RPC_MAXDATASIZE))
 			return (false);
 		if (!xdr_pointer
 		    (xdrs, (char **)&objp->next, sizeof(rpcbs_rmtcalllist),
@@ -143,7 +145,7 @@ xdr_rpcbs_rmtcalllist(XDR *xdrs, rpcbs_rmtcalllist *objp)
 		return (false);
 	if (!xdr_int(xdrs, &objp->indirect))
 		return (false);
-	if (!xdr_string(xdrs, &objp->netid, (u_int) ~0))
+	if (!xdr_string(xdrs, &objp->netid, RPC_MAXDATASIZE))
 		return (false);
 	if (!xdr_pointer
 	    (xdrs, (char **)&objp->next, sizeof(rpcbs_rmtcalllist),
diff --git a/src/xdr.c b/src/xdr.c
index 0e9e57c..b3975e0 100644
--- a/src/xdr.c
+++ b/src/xdr.c
@@ -56,7 +56,7 @@ typedef u_quad_t u_longlong_t;	/* ANSI unsigned long long type */
  */
 #define XDR_FALSE ((long) 0)
 #define XDR_TRUE ((long) 1)
-#define LASTUNSIGNED ((u_int) 0-1)
+#define RPC_MAXDATASIZE 9000
 
 /*
  * for unit alignment
@@ -504,6 +504,7 @@ xdr_bytes(XDR *xdrs, char **cpp, u_int *sizep, u_int maxsize)
 {
 	char *sp = *cpp;	/* sp is the actual string pointer */
 	u_int nodesize;
+	bool ret, allocated = false;
 
 	/*
 	 * first deal with the length since xdr bytes are counted
@@ -523,12 +524,21 @@ xdr_bytes(XDR *xdrs, char **cpp, u_int *sizep, u_int maxsize)
 	case XDR_DECODE:
 		if (nodesize == 0)
 			return (true);
-		if (sp == NULL)
+		if (sp == NULL) {
 			*cpp = sp = mem_alloc(nodesize);
+			allocated = true;
+		}
 		/* FALLTHROUGH */
 
 	case XDR_ENCODE:
-		return (xdr_opaque(xdrs, sp, nodesize));
+		ret = xdr_opaque(xdrs, sp, nodesize);
+		if ((xdrs->x_op == XDR_DECODE) && (ret == false)) {
+			if (allocated) {
+				free(sp);
+				*cpp = NULL;
+			}
+		}
+		return (ret);
 
 	case XDR_FREE:
 		if (sp != NULL) {
@@ -611,6 +621,7 @@ xdr_string(XDR *xdrs, char **cpp, u_int maxsize)
 	char *sp = *cpp;	/* sp is the actual string pointer */
 	u_int size = 0;
 	u_int nodesize;
+	bool ret, allocated = false;
 
 	/*
 	 * first deal with the length since xdr strings are counted-strings
@@ -647,13 +658,22 @@ xdr_string(XDR *xdrs, char **cpp, u_int maxsize)
 	switch (xdrs->x_op) {
 
 	case XDR_DECODE:
-		if (sp == NULL)
+		if (sp == NULL) {
 			*cpp = sp = mem_alloc(nodesize);
+			allocated = true;
+		}
 		sp[size] = 0;
 		/* FALLTHROUGH */
 
 	case XDR_ENCODE:
-		return (xdr_opaque(xdrs, sp, size));
+		ret = xdr_opaque(xdrs, sp, size);
+		if ((xdrs->x_op == XDR_DECODE) && (ret == false)) {
+			if (allocated) {
+				free(sp);
+				*cpp = NULL;
+			}
+		}
+		return (ret);
 
 	case XDR_FREE:
 		mem_free(sp, nodesize);
@@ -671,7 +691,7 @@ xdr_string(XDR *xdrs, char **cpp, u_int maxsize)
 bool
 xdr_wrapstring(XDR *xdrs, char **cpp)
 {
-	return xdr_string(xdrs, cpp, LASTUNSIGNED);
+	return xdr_string(xdrs, cpp, RPC_MAXDATASIZE);
 }
 
 /*
-- 
2.9.3

